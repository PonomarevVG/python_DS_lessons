#**Задание на повторение материала

import numpy as np


print("Задание 1")
#Создать одномерный массив Numpy под названием a из 12 последовательных целых чисел чисел от 12 до 24 невключительно

a = np.arange(12, 24)
print(a)

print("\nЗадание 2")
#Создать 5 двумерных массивов разной формы из массива a. Не использовать в аргументах метода reshape число -1.
print("\nМассив 1")
print(a.reshape(3, 4))

print("\nМассив 2")
print(a.reshape(2, 6))

print("\nМассив 3")
print(a.reshape(4, 3))

print("\nМассив 4")
print(a.reshape(6, 2))

print("\nМассив 5")
print(a.reshape(12, 1))


print("\nЗадание 3")
#Создать 5 двумерных массивов разной формы из массива a. Использовать в аргументах метода reshape число -1 (в трех
# примерах - для обозначения числа столбцов, в двух - для строк).
print("\nМассив 1")
print(a.reshape(-1, 4))

print("\nМассив 2")
print(a.reshape(-1, 6))

print("\nМассив 3")
print(a.reshape(4, -1))

print("\nМассив 4")
print(a.reshape(6, -1))

print("\nМассив 5")
print(a.reshape(12, -1))


print("\nЗадание 4")
#Можно ли массив Numpy, состоящий из одного столбца и 12 строк, назвать одномерным?
print("\nНет")


print("\nЗадание 5")
#Создать массив из 3 строк и 4 столбцов, состоящий из случайных чисел с плавающей запятой из нормального распределения
# со средним, равным 0 и среднеквадратичным отклонением, равным 1.0. Получить из этого массива одномерный массив с
# таким же атрибутом size, как и исходный массив.
ar = np.random.randn(3, 4)
print(ar.flatten())


print("\nЗадание 6")
#Создать массив a, состоящий из целых чисел, убывающих от 20 до 0 невключительно с интервалом 2.
a = np.arange(20, 0, -2)
print(a)


print("\nЗадание 7")
#Создать массив b, состоящий из 1 строки и 10 столбцов: целых чисел, убывающих от 20 до 1 невключительно с интервалом 2.
# В чем разница между массивами a и b?
b = a.reshape(1, 10)
print(b)
print("Разница в том, что массив a-одномерный, а массив b-двухмерный, хотя в нем всего одная строка")


print("\nЗадание 8")
#Вертикально соединить массивы a и b. a - двумерный массив из нулей, число строк которого больше 1 и на 1 меньше,
# чем число строк двумерного массива b, состоящего из единиц. Итоговый массив v должен иметь атрибут size, равный 10.
a = np.zeros(4).astype(int).reshape(2, 2)
b = np.ones(6).astype(int).reshape(3, 2)
print(np.vstack((a, b)))

print("\nЗадание 9")
#Создать одномерный массив а, состоящий из последовательности целых чисел от 0 до 12. Поменять форму этого массива,
# чтобы получилась матрица A (двумерный массив Numpy), состоящая из 4 строк и 3 столбцов. Получить матрицу At путем
# транспонирования матрицы A. Получить матрицу B, умножив матрицу A на матрицу At с помощью матричного умножения.
# Какой размер имеет матрица B? Получится ли вычислить обратную матрицу для матрицы B и почему?
a = np.arange(0, 12)
A = a.reshape(4, 3)
At = A.T
print("Матрица B")
B = np.dot(A, At)
print(B)
print(f"Определитель матрицы = {np.linalg.det(B)}")
print(f"Нельзя найти обратную матрицу, т.к. определитель равен 0")


print("\nЗадание 10")
#Инициализируйте генератор случайных числе с помощью объекта seed, равного 42.
print(np.random.seed(42))


print("\nЗадание 11")
#Создайте одномерный массив c, составленный из последовательности 16-ти случайных равномерно распределенных целых чисел
# от 0 до 16 невключительно.
c = np.random.randint(0, 16, 16)
print(c)


print("\nЗадание 12")
#Поменяйте его форму так, чтобы получилась квадратная матрица C. Получите матрицу D, поэлементно прибавив матрицу B
# из предыдущего вопроса к матрице C, умноженной на 10. Вычислите определитель, ранг и обратную матрицу D_inv для D.
C = c.reshape(4, 4)
D = C * 10 + B
print("Матрица D: ")
print(D)
print(f"Определитель матрицы D = {np.linalg.det(D)}, ранг = {np.linalg.matrix_rank(D)}")
print("Обратная матрица: ")
D_inv = np.linalg.inv(D)
print(D_inv)


print("\nЗадание 13")
#Приравняйте к нулю отрицательные числа в матрице D_inv, а положительные - к единице. Убедитесь, что в матрице D_inv
# остались только нули и единицы. С помощью функции numpy.where, используя матрицу D_inv в качестве маски, а матрицы
# B и C - в качестве источников данных, получите матрицу E размером 4x4.  Элементы матрицы E, для которых
# соответствующий элемент матрицы D_inv равен 1, должны быть равны соответствующему элементу матрицы B, а элементы
# матрицы E, для которых соответствующий элемент матрицы D_inv равен 0, должны быть равны соответствующему элементу
# матрицы C.
D_inv = (D_inv > 0).astype(int)
print("Убедимся, что в матрице D_inv, нули и единицы:")
print(D_inv)
print("Матрица B: ")
print(B)
print("Матрица C: ")
print(C)
E = np.where(D_inv == 1, B, C)
print("Матрица E: ")
print(E)
